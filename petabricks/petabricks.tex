\documentclass[a4paper, 11pt, twoside]{article}

\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{a4wide}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{listings}
\usepackage[margin=0.85in]{geometry}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\doublespacing
\graphicspath{{./img/}}

\usepackage{tikz}
\usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
    decorations.pathreplacing,decorations.pathmorphing,shapes,%
    matrix,shapes.symbols}

\tikzset{
>=stealth',
  punktchain/.style={
    rectangle, 
    rounded corners, 
    % fill=black!10,
    draw=black, very thick,
    text width=8em, 
    minimum height=3em, 
    text centered, 
    on chain},
  fillchain/.style={
    rectangle, 
    rounded corners, 
    fill=blue!30,
    draw=black, very thick,
    text width=8em, 
    minimum height=3em, 
    text centered, 
    on chain},
  line/.style={draw, thick, <-},
  element/.style={
    tape,
    top color=white,
    bottom color=blue!50!black!60!,
    minimum width=8em,
    draw=blue!40!black!90, very thick,
    text width=8em, 
    minimum height=3.5em, 
    text centered, 
    on chain},
  every join/.style={->, thick,shorten >=1pt},
  decoration={brace},
  tuborg/.style={decorate},
  tubnode/.style={midway, right=2pt},
}

\lstset{
    basicstyle=\footnotesize,
    morekeywords={either,or,transform,rule,to,from,through,function},
    frame=L,
}

\begin{document}

\hypersetup{backref,pdfpagemode=FullScreen,colorlinks=true}

\title{Introdução ao Sistema PetaBricks}
\author{Pedro Bruel}
\maketitle

%\input{./title.tex}

%\tableofcontents
%\newpage

%\begin{abstract}
%\line(1,0){350}
%\line(1,0){350}
%\end{abstract}

\section{Introdução}

Encontram-se na literatura diversos de métodos e ferramentas para otimização de
código relacionados à técnica do \emph{autotuning} que, considerando a rápida 
mudança e a grande variedade de arquiteturas de computador, visam minimizar o 
esforço associado ao desenvolvimento e manutenção de código portável, funcional
e eficiente, além de explorar de forma mais completa o paralelismo potencial de
arquiteturas \emph{multicore} modernas, cada vez mais ubíquas.

Otimizar um programa através do \emph{autotuning} pode envolver modelagens da
arquitetura alvo ou buscas empíricas no espaço de possíveis soluções. No 
processo de busca empírica, alguns compiladores realizam uma calibragem dos 
parâmetros de compilação~\cite{whaley1998,yotov2003} para a arquitetura alvo,
e utilizam essa calibragem para gerar código otimizado para essa arquitetura. 
Outros trabalhos~\cite{goldman2012framework,mitcsail-tr:2014,vuduc2004} propõe
uma abordagem diferente, onde são geradas e executadas variadas combinações
de algoritmos que resolvem um mesmo problema, comparando seus desempenhos para
selecionar a melhor combinação para uma dada arquitetura.
Yotov et al.~\cite{yotov2003} compara a otimização por busca empírica e por 
modelagem, apresentando um modelo com desempenho comparável à busca empírica.
Vuduc et al.~\cite{vuduc2004} apresenta e compara alguns
modelos estatísticos que auxiliam no processo de busca empírica. 

O sistema PetaBricks~\cite{ansel2009petabricks, ansel2014phd, 
ansel:xrds:2010, mitcsail-tr:2014}
consiste em uma linguagem, um compilador, e um ambiente de execução,
e seu objetivo é encontrar combinações algorítmicas que tenham o melhor 
desempenho na arquitetura alvo, através de uma busca empírica num espaço
de soluções definido pelo programador.

A linguagem PetaBricks (\emph{.pbcc}) facilita o processo de 
otimização por busca, expondo ao compilador as escolhas algorítmicas para 
solução de um problema e suas ordens de execução válidas. O programa é 
compilado para a linguagem C++ e então passa pelo \emph{autotuner} 
~\cite{ansel2011efficient}, que utiliza um algoritmo genético para gerar e 
testar diferentes combinações, produzindo uma configuração otimizada para 
execução na arquitetura alvo.

\section{O Autotuning} \label{sec:autotuning}

Ao desenvolver uma solução portável e eficiente para um problema, o
programador deve considerar, entre outros fatores, as diversas possibilidades
de implementação dos algorítimos que resolvem o problema. A escolha da melhor
implementação depende em grande parte das arquiteturas e ambientes em que se 
pretende executar o programa, e o programador realiza essa escolha baseado
em seus conhecimentos das arquiteturas alvo e resultados de testes que realiza
durante o desenvolvimento. 

Dadas a heterogeneidade das arquiteturas de computador modernas e sua rápida 
taxa de mudança, o trabalho de produzir implementações portáveis e eficientes 
dependerá cada vez mais conhecimentos específicos sobre um processador,
motivando o desenvolvimento de técnicas automáticas de seleção das melhores
implementações para solução de um problema, isto é, o \emph{autotuning} de um
conjunto de soluções possíveis.

O problema do \emph{autotuning}, através do processo de escolha algorítmica,
pode ser descrito da seguinte forma~\cite{ansel2011efficient}:

Considere o conjunto $A$ de algoritmos que resolvem instâncias de um dado 
problema, o conjunto $S$ de seletores para esses algoritmos, e o conjunto $S_t$
de seletores para parâmetros de compilação e configuração no conjunto $B$.

O seletor $s \in S$ de algoritmos em $A$ consiste em 
$\overrightarrow{C_s} = [c_{s,1},\dots,c_{s,m-1}] \cup \overrightarrow{A_s} = 
[\alpha_{s,1},\dots,\alpha_{s,m-1}]$,
onde cada $c_{s,i} \in \overrightarrow{C_s}$ representa um intervalo 
relacionado a um tamanho de entrada para a instância, e 
determina a execução do algoritmo $\alpha_{s,i} \in \overrightarrow{A_s}, 
\quad \alpha_{s,i} \in A$ neste intervalo. 

Além disso, $min(n) \leq c_{s,1} < n < c_{s,m-1} \leq max(n)$,
onde $n$ é o tamanho da entrada para a instância sendo selecionada, e $m$ 
é determinado pela instância.

Assim, um seletor $s \in S$ seleciona algoritimos da seguinte forma:

\begin{equation*}
    SELECT(s, i) = \alpha_{s,i} \in \overrightarrow{A_{s}} \quad | \quad c_{s,i} \in \overrightarrow{C_{s}},
    \quad\quad 1 \leq i < m
\end{equation*}

Além de um seletor para algoritmos, podemos especificar seletores $s_t \in S_t$,
compostos de $\overrightarrow{B_{s_t}} = [\beta_{s_t,1},\dots,\beta_{s_t,b-1}] 
\cup \overrightarrow{V_{s_t}} = [v_{s_t,1},\dots,v_{s_t,b-1}]$,
onde cada $\beta_{s_t,j} \in \overrightarrow{B_{s_t}}$ representa um parâmetro
de compilação ou configuração para a instância do problema, que assume o valor
especificado por $v_{s_t,i} \in \overrightarrow{V_{s_t}}$.

O seletor $s_t$ seleciona um valor para cada parâmetro de compilação e 
configuração definido para a instância:

\begin{equation*}
    SELECT_{\beta}(s_t, j) = v_{s_t,j} \in \overrightarrow{V_{s_t}} \quad | \quad \beta_{s_t,j} \in \overrightarrow{B_{s_t}},
    \quad\quad 1 \leq j < b
\end{equation*}

Com os seletores $s$ e $s_t$, podemos especificar um programa
$P_{s,s_t}$, e o objetivo de um \emph{autotuner} ideal é encontrar
os seletores $s^*,s_{t}^{*}$ que especifiquem o programa $P_{s^*,s_{t}^{*}}$, 
ou $P^*$, cujo tempo de execução $t^*$ --- representado por $T(P^*,H,n)$ --- 
é calculado executando-se o programa na arquitura $H$, com entrada de tamanho
$n$, e deve satisfazer:

\begin{equation*}
    t^* = T(P^*,H,n) \leq T(P_{s^*,s_{t}^{*}},H,n), \quad \forall s \in S, \quad \forall s_t \in S_t
\end{equation*}

Alguns detalhes do algoritmo para o \emph{autotuning} utilizado pelo PetaBricks
são discutidos na Seção~\ref{sec:autotuner}.

Em geral, o tempo de execução dos programas especificados pelos seletores
é proporcional ao tamanho de entrada --- se não for o caso, o
\emph{autotuning} não tem mesmo utilidade --- mas diminui conforme
se encontram melhores soluções. Apesar disso, o tempo de execução sofre
interferência de muitos fatores, como por exemplo outros processos executados
pelo sistema operacional, que competem por recursos computacionais.

Essas propriedades de avaliação do desempenho da soluções para um problema 
contribuem para o desenvolvimento e a escolha dos métodos
que serão utilizados no \emph{autotuner}.

\section{Linguagem}

Tomando como exemplo o problema da ordenação de vetores, um programa na
linguagem do sistema PetaBricks pode utilizar a primitiva \emph{either...or} 
(Figura~\ref{fig:sort2pbcc}) ou os conceitos de \emph{transform} e \emph{rule}
(Figura~\ref{fig:sortpbcc}) para determinar o espaço de algoritmos que podem 
ser combinados para gerar uma solução eficiente.

A primitiva \emph{either...or} permite definir explicitamente um espaço
de algoritmos, e cabe ao \emph{autotuner} selecionar uma dentre as cláusulas
do \emph{either...or} a cada vez que a primitiva é executada.

Uma \emph{transform} é análoga a uma função, contendo código que pode
ser chamado por outras \emph{transforms}, por código em outras linguagens
ou pela linha de comando. O cabeçalho de uma \emph{transform} pode ser composto
dos argumentos \emph{from}, \emph{to} e \emph{through}, que representam a
memória correspondente à entrada, saída e intermediários usados na 
\emph{transform}.

As possíveis escolhas de algoritmos feitas pelo programador são expostas 
em \emph{rules} dentro de uma \emph{transform}, que definem um algoritmo
para tratar determinada região de dados. O cabeçalho de uma \emph{rule} pode
conter argumentos para variáveis de entrada, saída, e possíveis restrições sua 
para aplicação, codificados pelas primitivas \emph{from}, \emph{to} e 
\emph{where}.

No código da Figura~\ref{fig:sortpbcc} são definidas diversas \emph{rules}
para o \emph{MergeSort} de subvetores de tamanhos diferentes. Cada regra
para ordenar subvetores deve estar definida em \emph{transforms} presentes
no código original, ou incluídas de outros arquivos.

\begin{figure}[H]
    \lstinputlisting[firstline=1, lastline=24]{./code/Sort.pbcc}
    ...
    \lstinputlisting[firstline=40, lastline=55]{./code/Sort.pbcc}
    \centering
    \caption{Sort.pbcc}
    \label{fig:sortpbcc}
\end{figure}

\begin{figure}[H]
    \centering
    \lstinputlisting{./code/Sort2.pbcc}
    \caption{Sort2.pbcc}
    \label{fig:sort2pbcc}
\end{figure}

\section{Compilador}

\begin{figure}[H]
    \begin{tikzpicture}
        [node distance=.8cm,
        start chain=going right]
            \node[fillchain, join] (compiler) {Compilador};
            \begin{scope}[start branch=peta]
                \node[punktchain, on chain=going above] (pbcc) {Código \emph{.pbcc}};
            \end{scope}
            \node[punktchain, join] (cpp) {Código C++};
            \node[punktchain, join] (bin) {Binário};
            \begin{scope}[start branch=tuner]
                \node[fillchain, on chain=going above] (auto) {Autotuner};
            \end{scope}
            \node[punktchain, join] (exe) {Execução};
            \begin{scope}[start branch=conf]
                \node[punktchain, on chain=going above] (arqconf) {Arquivo de Configuração};
            \end{scope}
            \begin{scope}[start branch=env]
                \node[fillchain, on chain=going below] (envexe) {Ambiente de Execução};
            \end{scope}
            \draw[|-,-|,->, thick,] (arqconf.south) |-+(0,-1em)-| (exe.north);
            \draw[|-,-|,->, thick,] (envexe.north) |-+(0,0)-| (exe.south);
            \draw[|-,-|,<->, thick,] (bin.north) |-+(0,2em)-| (auto.south);
            \draw[|-,-|,<->, thick,] (auto.north) |-+(0,2em)-| (arqconf.north);
            \draw[|-,-|,->, thick,] (pbcc.south) |-+(0,0)-| (compiler.north);
    \end{tikzpicture}
    \centering
    \caption{Estrutura do Sistema PetaBricks}
    \label{fig:petabricks-overview}
\end{figure}

O compilador do PetaBricks contém três componentes principais: um 
compilador fonte-para-fonte da linguagem PetaBricks para C++; um 
\emph{autotuner}; e uma biblioteca de execução utilizada pelo código gerado.
Esses componentes permitem ao sistema PetaBricks decidir quais algoritmos 
utilizar, como distribuir computações e dados nos rescursos disponíveis, e como
explorar o paralelismo do código. A Figura~\ref{fig:petabricks-overview} 
ilustra as relações entre esses componentes e os dados que utilizam no processo
de compilação.

O compilador realiza a análise sintática do código
fonte, determina as regiões onde cada regra pode ser aplicada, analisa
os grafos de dependências do programa e gera código em C++.

O código gerado é usado pelo autotuner, dando início ao processo de busca no 
espaço das escolhas algorítmicas definidas no código. Diferentes versões
do programa serão geradas e executadas, contendo combinações de parâmetros de
compilação e algoritmos diferentes, e produzirão arquivos de configuração que
podem servir de parâmetro para a continuação do processo de busca ou para gerar
um arquivo executável final já otimizado.

\section{Autotuner}\label{sec:autotuner}

O \emph{autotuner} do PetaBricks realiza a busca pela melhor solução de 
determinado problema, representada por uma combinação dos algoritmos 
especificados pelo programador. O \emph{INCREA}~\cite{ansel2011efficient} é o 
algoritmo genético responsável por gerar e avaliar as possíveis soluções 
no \emph{autotuner}, e faz isso de maneira incremental, começando
o processo de seleção sobre codificações mais simples de solução e utilizando 
os resultados obtidos para orientar a busca sobre codificações mais complexas.

A estratégia do \emph{INCREA} funciona bem quando o tamanho da codificação
implica num alto custo de avaliação da solução mas, ao mesmo tempo, soluções
melhores têm um custo menor. Isso acontece pois o algoritmo começa utilizando
problemas de tamanho pequeno e aumenta o tamanho da codificação utilizada na 
seleção conforme encontra boas soluções, garantindo que as maiores codificações
encontradas serão próximas a candidatos com boa avaliação e portanto terão um
baixo custo de avaliação. Outra vantagem do algoritmo é ter bons resultados
quando o processo de avaliação apresenta ruído ou alta variação nas medidas.
Em contrapartida, o algoritmo não tem bons resultados quando o espaço de busca
contém \emph{local optima} ou as soluções de codificações menores não são
reutilizáveis para soluções maiores.

O genoma que codifica as soluções tem tamanho $(2m + 1)k + n$,
onde $k$ representa o número de seletores, $m$ os
limites dos intervalos para cada algoritmo e $n$ o número de \emph{tunables} 
utilizados na seleção. O número de pares de algoritmos e limites de intervalo
ativos no genoma começa em $1$ e é incrementado a cada geração.

A avaliação de codificações consiste em executar o programa gerado pela
configuração representada no genoma, o valor do \emph{fitness} é o inverso
do tempo de execução. O tamanho da entrada testada na execução do programa
começa em $1$ e dobra a cada geração.

\section{Exemplos}

\newpage
\bibliographystyle{plain}
\bibliography{petabricks}

\end{document}
